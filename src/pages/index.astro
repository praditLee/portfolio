---
import MainLayout from "../layouts/MainLayout.astro";
import ProjectCard from "../components/ProjectCard.astro";
import { getCollection } from "astro:content";

// 1. นิยามฟังก์ชัน SHUFFLE
function shuffle(array) {
  let currentIndex = array.length,
    randomIndex;
  while (currentIndex != 0) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex],
      array[currentIndex],
    ];
  }
  return array;
}

// 2. ดึงข้อมูลจาก CONTENT COLLECTIONS
const projectsFromCollection = await getCollection("projects");

const allProjects = projectsFromCollection.map((project) => ({
  title: project.data.title,
  category: project.data.category,
  tags: project.data.tags,
  imageUrl: project.data.imageUrl,
  gallery: project.data.gallery || [],
  type: project.data.type,
  videoUrl: project.data.videoUrl || "",
  description: project.body,
  slug: project.slug, // เพิ่ม slug เพื่อใช้เป็น ID ที่ไม่ซ้ำ
}));

// 3. เตรียมข้อมูลสำหรับ FILTERS และการแสดงผล
const allCategories = [
  "All",
  ...new Set(allProjects.map((p) => p.category).filter(Boolean)),
];
const allTags = [...new Set(allProjects.flatMap((project) => project.tags))];
const shuffledProjects = shuffle([...allProjects]);
---

<MainLayout title="My Portfolio - Home">
  <section id="homepage-portfolio">
    <h1>My Works</h1>
    <p>รวบรวมผลงานเด่นจากทุกหมวดหมู่</p>

    <div class="category-filters">
      {
        allCategories.map((category) => (
          <button
            class:list={["category-btn", { "is-active": category === "All" }]}
            data-category={category}
          >
            {category}
          </button>
        ))
      }
    </div>

    <div class="filter-tags" id="tag-filter-container">
      {
        allTags.map((tag) => (
          <button class="filter-btn" data-tag={tag}>
            {tag}
          </button>
        ))
      }
    </div>

    <div class="masonry-grid">
      {
        shuffledProjects.map((project) => (
          <div
            class="masonry-item"
            data-tags={project.tags.join(",")}
            data-category={project.category}
            data-slug={project.slug}
          >
            <ProjectCard {...project} />
          </div>
        ))
      }
    </div>
  </section>
</MainLayout>

<style>
  /* CSS ทั้งหมดที่เคยทำมาสำหรับหน้านี้ (masonry, filter buttons, etc.) */
  .masonry-grid {
    column-count: 3;
    column-gap: var(--spacing-md);
  }
  .masonry-item {
    break-inside: avoid;
    margin-bottom: var(--spacing-md);
    transition: all 0.4s ease-in-out;
  }
  .masonry-item.hidden {
    transform: scale(0.8);
    opacity: 0;
    max-height: 0;
    padding: 0;
    margin: 0;
    overflow: hidden;
    border: none;
  }
  h1,
  p {
    text-align: center;
    margin-left: auto;
    margin-right: auto;
  }
  .category-filters {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
    padding-bottom: var(--spacing-md);
    border-bottom: 1px solid var(--color-border);
  }
  .category-btn {
    background: none;
    border: none;
    padding: 0.5rem;
    font-family: var(--font-heading);
    font-weight: 600;
    font-size: 1rem;
    color: var(--color-text-secondary);
    cursor: pointer;
    position: relative;
    transition: color 0.2s ease;
  }
  .category-btn:hover {
    color: var(--color-text-primary);
  }
  .category-btn.is-active {
    color: var(--color-primary);
  }
  .filter-tags {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
  }
  .filter-btn {
    background-color: transparent;
    color: var(--color-text-secondary);
    border: 1px solid var(--color-border);
    padding: 0.5rem 1rem;
    border-radius: 999px;
    font-family: var(--font-heading);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .filter-btn:hover {
    background-color: var(--color-surface);
    border-color: var(--color-primary);
  }
  .filter-btn.is-active {
    background-color: var(--color-primary);
    color: white;
    border-color: var(--color-primary);
  }
  @media (max-width: 1024px) {
    .masonry-grid {
      column-count: 2;
    }
  }
  @media (max-width: 768px) {
    .masonry-grid {
      column-count: 1;
    }
  }
</style>

<script>
  import GLightbox from "glightbox";

  // === DOM ELEMENTS ===
  const categoryButtons = document.querySelectorAll(".category-btn");
  const tagFilterContainer = document.getElementById("tag-filter-container");
  const portfolioItems = document.querySelectorAll(".masonry-item");
  const masonryGrid = document.querySelector(".masonry-grid");

  // === STATE ===
  let activeCategory = "All";
  let activeTags = new Set();

  // === FUNCTIONS ===
  function updateView() {
    const visibleItems = [];
    portfolioItems.forEach((item) => {
      const itemCategory = item.dataset.category;
      const categoryMatch =
        activeCategory === "All" || itemCategory === activeCategory;
      if (categoryMatch) {
        visibleItems.push(item);
        const itemTags = item.dataset.tags.split(",");
        const tagMatch =
          activeTags.size === 0 || itemTags.some((tag) => activeTags.has(tag));
        if (tagMatch) {
          item.classList.remove("hidden");
        } else {
          item.classList.add("hidden");
        }
      } else {
        item.classList.add("hidden");
      }
    });
    updateAvailableTags(visibleItems);
  }

  function updateAvailableTags(visibleItems) {
    const availableTags = new Set();
    visibleItems.forEach((item) => {
      if (!item.classList.contains("hidden")) {
        item.dataset.tags.split(",").forEach((tag) => availableTags.add(tag));
      }
    });
    tagFilterContainer.querySelectorAll(".filter-btn").forEach((btn) => {
      if (activeCategory === "All" || availableTags.has(btn.dataset.tag)) {
        btn.style.display = "inline-block";
      } else {
        btn.style.display = "none";
      }
    });
  }

  // === EVENT LISTENERS (Filtering) ===
  categoryButtons.forEach((btn) => {
    btn.addEventListener("click", (event) => {
      const clickedCategory = event.target.dataset.category;
      if (clickedCategory === activeCategory) return;
      activeCategory = clickedCategory;
      categoryButtons.forEach((b) => b.classList.remove("is-active"));
      event.target.classList.add("is-active");
      activeTags.clear();
      tagFilterContainer
        .querySelectorAll(".filter-btn")
        .forEach((b) => b.classList.remove("is-active"));
      updateView();
    });
  });

  tagFilterContainer.addEventListener("click", (event) => {
    if (!event.target.matches(".filter-btn")) return;
    const button = event.target;
    const selectedTag = button.dataset.tag;
    button.classList.toggle("is-active");
    if (activeTags.has(selectedTag)) {
      activeTags.delete(selectedTag);
    } else {
      activeTags.add(selectedTag);
    }
    updateView();
  });

  // === EVENT LISTENER (Lightbox) ===
  masonryGrid.addEventListener("click", (event) => {
    const lightboxTrigger = event.target.closest(".card-image-link.glightbox");
    if (!lightboxTrigger) return;
    event.preventDefault();

    const visibleItems = document.querySelectorAll(
      ".masonry-item:not(.hidden)"
    );
    const galleryElements = [];
    let clickedIndex = -1;

    visibleItems.forEach((item) => {
      const links = item.querySelectorAll(".glightbox");
      let itemStartIndex = galleryElements.length;
      links.forEach((link, linkIndex) => {
        const descriptionForSlide =
          linkIndex === 0 ? link.dataset.description : "";
        galleryElements.push({
          href: link.href,
          description: descriptionForSlide,
        });
      });
      if (item.contains(lightboxTrigger)) {
        clickedIndex = itemStartIndex;
      }
    });

    if (galleryElements.length > 0) {
      const dynamicLightbox = GLightbox({
        elements: galleryElements,
        startAt: clickedIndex >= 0 ? clickedIndex : 0,
        loop: true,
        slideEffect: "slide", // << กลับมาใช้ slide แบบปกติ
        autoplayVideos: false, // << ยังคงปิด Autoplay ไว้
      });
      dynamicLightbox.open();
    }
  });

  // Initial render
  updateView();
</script>
